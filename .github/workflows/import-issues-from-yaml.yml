name: Import Issues from YAML

on:
  workflow_dispatch:
    inputs:
      file:
        description: "Path to YAML (e.g. ops/issues/m0-child-issues.yml)"
        required: true
        default: "ops/issues/m0-child-issues.yml"
      dry_run:
        description: "If true: do not create anything, only print what would happen"
        required: true
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      update_parent_epic_checklists:
        description: "If true: update parent epic checklist items to link created issues (uses raw_title)"
        required: true
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

permissions:
  issues: write

jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug workspace
        run: |
          echo "PWD: $(pwd)"
          echo "Workspace root:"
          ls -la
          echo "ops:"
          ls -la ops || true
          echo "ops/issues:"
          ls -la ops/issues || true
          echo "Find YAML candidates:"
          find . -maxdepth 6 -type f \( -name "*.yml" -o -name "*.yaml" \) -print

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install js-yaml
        run: npm install js-yaml

      - name: Import issues (or dry-run)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const yaml = require("js-yaml");

            const yamlPath = (core.getInput("file") || "").trim();
            const dryRun = ((core.getInput("dry_run") || "true").trim() === "true");
            const updateEpic = ((core.getInput("update_parent_epic_checklists") || "false").trim() === "true");

            core.info(`Input YAML path: "${yamlPath}"`);
            core.info(`DRY RUN: ${dryRun}`);
            core.info(`Update epic checklists: ${updateEpic}`);

            if (!yamlPath) {
              core.setFailed('Input "file" is empty');
              return;
            }
            if (!fs.existsSync(yamlPath)) {
              core.setFailed(`YAML file not found: ${yamlPath}`);
              return;
            }

            const doc = yaml.load(fs.readFileSync(yamlPath, "utf8"));
            const milestoneNumber = doc.milestone_number;
            const milestoneTitle = doc.milestone;
            const issues = doc.issues || [];

            if (!milestoneNumber && !milestoneTitle) {
              core.setFailed("YAML must include either 'milestone_number' or 'milestone'.");
              return;
            }

            // Resolve milestone number (prefer milestone_number)
            let msNumber = milestoneNumber;
            let msTitleForLog = milestoneTitle || `(by number ${milestoneNumber})`;

            if (!msNumber) {
              const milestones = await github.paginate(github.rest.issues.listMilestones, {
                ...context.repo,
                state: "all",
                per_page: 100,
              });
              const ms = milestones.find(m => m.title === milestoneTitle);
              if (!ms) {
                core.setFailed(`Milestone not found (must match exactly): "${milestoneTitle}"`);
                return;
              }
              msNumber = ms.number;
              msTitleForLog = ms.title;
            }

            core.info(`Using milestone #${msNumber}: ${msTitleForLog}`);
            core.info(`Issues in YAML: ${issues.length}`);

            // ---- Helpers
            async function issueExistsExactTitle(title) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue in:title "${title.replace(/"/g, '\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 50 });
              return res.data.items.some(i => i.title === title);
            }

            async function findEpicByTitle(title) {
              if (!title) return null;
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue label:"type:epic" in:title "${title.replace(/"/g, '\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 10 });
              const exact = res.data.items.find(i => i.title === title);
              return exact || res.data.items[0] || null;
            }

            function mdChecklist(items) {
              if (!items || items.length === 0) return "_(none)_";
              return items.map(x => `- [ ] ${x}`).join("\n");
            }

            function buildBody(item, epicNumberOrNull) {
              const b = item.body || {};
              const out = [];

              if (item.type === "chore") {
                out.push(`## Chore type\n${b.chore_type || "tooling (scripts, CI, automation)"}\n`);
              }

              out.push(`## What\n${b.what || ""}\n`);
              out.push(`## Why\n${b.why || ""}\n`);
              out.push(`## Definition of Done\n${mdChecklist(b.definition_of_done || [])}\n`);
              out.push(`## System\n${b.system || ""}\n`);
              out.push(`## Priority\n${b.priority || ""}\n`);

              if (b.notes) out.push(`## Notes / links\n${b.notes}\n`);

              if (item.parent_epic) {
                if (epicNumberOrNull) out.push(`## Parent Epic\n- #${epicNumberOrNull}\n`);
                else out.push(`## Parent Epic\n- ${item.parent_epic}\n`);
              }

              out.push(`---\n**Area:** ${item.area || ""}  \n**Estimate:** ${item.estimate || ""}  \n**Risk:** ${item.risk || ""}\n`);
              return out.join("\n").trim() + "\n";
            }

            function escapeRegex(s) {
              return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            }

            async function linkIntoEpicChecklist(epic, rawTitle, createdNum) {
              if (!rawTitle) return false;
              const body = epic.body || "";
              const re = new RegExp(`^- \\[ \\] ${escapeRegex(rawTitle)}\\s*$`, "m");
              if (!re.test(body)) return false;

              const updated = body.replace(re, `- [ ] #${createdNum} ${rawTitle}`);
              if (dryRun) {
                core.info(`[DRY-RUN] Would update epic #${epic.number} checklist line: "${rawTitle}" -> "#${createdNum} ${rawTitle}"`);
                return true;
              }

              await github.rest.issues.update({
                ...context.repo,
                issue_number: epic.number,
                body: updated,
              });
              return true;
            }

            // ---- Main loop
            let wouldCreate = 0;
            let wouldSkip = 0;
            let createdCount = 0;
            let skippedCount = 0;

            for (const item of issues) {
              const title = (item.title || "").trim();
              if (!title) continue;

              const exists = await issueExistsExactTitle(title);
              let epic = null;

              if (item.parent_epic) {
                epic = await findEpicByTitle(item.parent_epic);
              }

              if (exists) {
                if (dryRun) {
                  wouldSkip++;
                  core.info(`[DRY-RUN] Skip (exists): ${title}`);
                } else {
                  skippedCount++;
                  core.info(`Skip (exists): ${title}`);
                }
                continue;
              }

              const labels = item.labels || [];
              const body = buildBody(item, epic ? epic.number : null);

              if (dryRun) {
                wouldCreate++;
                core.info(`[DRY-RUN] Would create: "${title}" | milestone #${msNumber} | labels: ${JSON.stringify(labels)} | parent epic: ${epic ? "#" + epic.number : (item.parent_epic || "(none)")}`);
                continue;
              }

              const created = await github.rest.issues.create({
                ...context.repo,
                title,
                body,
                milestone: msNumber,
                labels,
              });

              createdCount++;
              core.info(`Created #${created.data.number}: ${title}`);

              if (updateEpic && epic && item.raw_title) {
                const ok = await linkIntoEpicChecklist(epic, item.raw_title, created.data.number);
                if (ok) core.info(`Updated epic checklist: ${epic.title} <- #${created.data.number}`);
              }
            }

            if (dryRun) {
              core.info(`DRY-RUN complete. Would create: ${wouldCreate}, Would skip: ${wouldSkip}`);
            } else {
              core.info(`Done. Created: ${createdCount}, Skipped: ${skippedCount}`);
            }
