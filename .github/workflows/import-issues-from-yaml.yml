name: Import Issues from YAML

on:
  workflow_dispatch:
    inputs:
      yaml_path:
        description: "Path to YAML (e.g. ops/issues/m1-child-issues.yml)"
        required: true
        default: "ops/issues/m0-child-issues.yml"
      # Backwards-compat alias (in case your older workflow used 'file')
      file:
        description: "(legacy) Path to YAML (leave blank if using yaml_path)"
        required: false
        default: ""
      dry_run:
        description: "If true: do not create/update anything, only print what would happen"
        required: true
        default: "true"
        type: choice
        options: ["true", "false"]
      update_parent_epic_checklists:
        description: "If true: update parent epic checklist items to link created/existing issues"
        required: true
        default: "false"
        type: choice
        options: ["true", "false"]

permissions:
  contents: read
  issues: write

jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install js-yaml
        run: npm i js-yaml

      - name: Import issues (or dry-run)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const yaml = require("js-yaml");

            // Accept both 'yaml_path' and legacy 'file'
            const yamlPath = core.getInput("yaml_path") || core.getInput("file");
            const dryRun = core.getInput("dry_run") === "true";
            const updateEpics = core.getInput("update_parent_epic_checklists") === "true";

            core.info(`Inputs received -> yaml_path="${core.getInput("yaml_path")}", file="${core.getInput("file")}"`);
            core.info(`Resolved YAML path -> "${yamlPath}"`);
            core.info(`dry_run=${dryRun}, update_parent_epic_checklists=${updateEpics}`);

            if (!yamlPath) {
              core.setFailed("Input 'yaml_path' is empty (and legacy 'file' is also empty)");
              return;
            }

            const absPath = path.join(process.env.GITHUB_WORKSPACE, yamlPath);
            if (!fs.existsSync(absPath)) {
              core.setFailed(`YAML file not found: ${yamlPath} (resolved to ${absPath})`);
              return;
            }

            const doc = yaml.load(fs.readFileSync(absPath, "utf8"));
            const issues = doc.issues || [];
            if (!Array.isArray(issues) || issues.length === 0) {
              core.setFailed("No issues found in YAML (expected top-level key 'issues:')");
              return;
            }

            // Milestone selection: prefer milestone_number (stable vs fancy dashes)
            const milestoneNumber = doc.milestone_number || doc.milestoneNumber || null;
            let milestone = null;

            if (milestoneNumber) {
              milestone = { number: Number(milestoneNumber) };
            } else if (doc.milestone) {
              const milestones = await github.paginate(github.rest.issues.listMilestones, {
                ...context.repo,
                state: "all",
                per_page: 100,
              });
              milestone = milestones.find(m => m.title === doc.milestone);
              if (!milestone) {
                core.setFailed(`Milestone not found (must match exactly): "${doc.milestone}"`);
                return;
              }
            } else {
              core.setFailed("Missing 'milestone_number' or 'milestone' at top of YAML");
              return;
            }

            const epicChildrenMap = new Map();

            async function findIssueByTitle(title) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue in:title "${title.replace(/"/g, '\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 20 });
              const matches = res.data.items.filter(it => it.title === title);
              return matches.length ? matches[0] : null;
            }

            async function createIssue(entry) {
              const title = entry.title;
              const bodyObj = entry.body || {};
              const body = typeof bodyObj === "string"
                ? bodyObj
                : Object.entries(bodyObj).map(([k,v]) => {
                    if (Array.isArray(v)) return `### ${k}\n${v.join("\n")}`;
                    return `### ${k}\n${String(v)}`;
                  }).join("\n\n");

              const labels = entry.labels || [];
              const milestoneNum = milestone.number;

              if (dryRun) {
                core.info(`[dry-run] Would create: ${title}`);
                return { number: null, html_url: null, title };
              }

              const created = await github.rest.issues.create({
                ...context.repo,
                title,
                body,
                labels,
                milestone: milestoneNum,
              });

              return created.data;
            }

            function recordChildForEpic(entry, issueData) {
              const parentEpic = entry.parent_epic;
              if (!parentEpic) return;
              if (!epicChildrenMap.has(parentEpic)) epicChildrenMap.set(parentEpic, []);
              epicChildrenMap.get(parentEpic).push({
                title: entry.raw_title || entry.title,
                number: issueData.number,
                url: issueData.html_url
              });
            }

            let createdCount = 0;
            let skippedCount = 0;

            for (const entry of issues) {
              const title = entry.title;
              if (!title) continue;

              const existing = await findIssueByTitle(title);

              if (existing) {
                skippedCount++;
                core.info(`Skipped (exists): #${existing.number} ${title}`);
                // IMPORTANT: still record for epic linking
                recordChildForEpic(entry, existing);
                continue;
              }

              const created = await createIssue(entry);
              if (created.number) {
                createdCount++;
                core.info(`Created #${created.number}: ${title}`);
                recordChildForEpic(entry, created);
              }
            }

            if (updateEpics) {
              if (dryRun) {
                core.info(`[dry-run] Would update epic checklists for ${epicChildrenMap.size} epics`);
              } else {
                for (const [epicTitle, children] of epicChildrenMap.entries()) {
                  const epic = await findIssueByTitle(epicTitle);
                  if (!epic) {
                    core.warning(`Parent epic not found by exact title: "${epicTitle}"`);
                    continue;
                  }

                  let body = epic.body || "";
                  for (const child of children) {
                    const safeTitle = child.title.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                    const re = new RegExp(`(^\\s*- \\[ \\] ${safeTitle})(?!\\s*#\\d+)`, "m");
                    body = body.replace(re, `$1 #${child.number}`);
                  }

                  await github.rest.issues.update({
                    ...context.repo,
                    issue_number: epic.number,
                    body,
                  });

                  core.info(`Updated epic checklist: ${epic.title} <- ${children.length} items`);
                }
              }
            }

            core.info(`Done. Created: ${createdCount}, Skipped: ${skippedCount}`);
