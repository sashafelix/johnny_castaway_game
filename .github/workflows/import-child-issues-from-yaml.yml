name: Import Child Issues from YAML (and link into Epic checklists)

on:
  workflow_dispatch:
    inputs:
      yaml_path:
        description: "Path to YAML (e.g. ops/issues/m1-child-issues.yml)"
        required: true
        default: "ops/issues/m1-child-issues.yml"
      dry_run:
        description: "If true: do not create or update anything, only print what would happen"
        required: true
        default: "true"
        type: choice
        options: ["true", "false"]
      update_epic_checklists:
        description: "If true: link child issues into the parent epic checklist (batched per epic)"
        required: true
        default: "true"
        type: choice
        options: ["true", "false"]
      max_existing_issue_pages:
        description: "How many pages (100/page) to scan for existing issue titles (reduce API calls)."
        required: true
        default: "5"

permissions:
  issues: write

jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Debug workspace
        run: |
          echo "PWD: $(pwd)"
          ls -la ops/issues || true
          find . -maxdepth 6 -type f \( -name "*.yml" -o -name "*.yaml" \) -print

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install js-yaml
        run: npm install js-yaml

      - name: Import issues (or dry-run)
        uses: actions/github-script@v7
        env:
          YAML_PATH: ${{ inputs.yaml_path }}
          DRY_RUN: ${{ inputs.dry_run }}
          UPDATE_EPIC_CHECKLISTS: ${{ inputs.update_epic_checklists }}
          MAX_EXISTING_PAGES: ${{ inputs.max_existing_issue_pages }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const path = require("path");
            const yaml = require("js-yaml");

            const yamlPathInput = (process.env.YAML_PATH || "").trim();
            const dryRun = ((process.env.DRY_RUN || "true").trim() === "true");
            const updateEpic = ((process.env.UPDATE_EPIC_CHECKLISTS || "true").trim() === "true");
            const maxExistingPages = parseInt((process.env.MAX_EXISTING_PAGES || "5").trim(), 10);

            core.info(`Inputs -> yaml_path="${yamlPathInput}", dry_run=${dryRun}, update_epic_checklists=${updateEpic}, max_existing_issue_pages=${maxExistingPages}`);

            if (!yamlPathInput) { core.setFailed('Input "yaml_path" is empty'); return; }

            const repoRoot = process.env.GITHUB_WORKSPACE || process.cwd();
            const resolvedYamlPath = path.isAbsolute(yamlPathInput)
              ? yamlPathInput
              : path.join(repoRoot, yamlPathInput);

            core.info(`Resolved YAML path -> ${resolvedYamlPath}`);

            if (!fs.existsSync(resolvedYamlPath)) {
              core.setFailed(`YAML file not found: ${resolvedYamlPath}`);
              return;
            }

            const doc = yaml.load(fs.readFileSync(resolvedYamlPath, "utf8"));

            const milestoneNumber = doc.milestone_number;
            const milestoneTitle = doc.milestone;
            const items = doc.issues || [];

            if (!milestoneNumber && !milestoneTitle) {
              core.setFailed("YAML must include either 'milestone_number' or 'milestone'.");
              return;
            }

            // Resolve milestone (prefer number)
            let msNumber = milestoneNumber;
            let msTitleForLog = milestoneTitle || `(by number ${milestoneNumber})`;

            if (!msNumber) {
              const milestones = await github.paginate(github.rest.issues.listMilestones, {
                ...context.repo,
                state: "all",
                per_page: 100,
              });
              const ms = milestones.find(m => m.title === milestoneTitle);
              if (!ms) { core.setFailed(`Milestone not found (must match exactly): "${milestoneTitle}"`); return; }
              msNumber = ms.number;
              msTitleForLog = ms.title;
            }

            core.info(`Using milestone #${msNumber}: ${msTitleForLog}`);
            core.info(`Issues in YAML: ${items.length}`);

            // -----------------------------
            // Existing issue title -> number cache
            // -----------------------------
            const existingTitleToNumber = new Map();
            core.info(`Scanning existing issues (up to ${maxExistingPages} pages @ 100/page)...`);
            for (let page = 1; page <= maxExistingPages; page++) {
              const res = await github.rest.issues.listForRepo({
                ...context.repo,
                state: "all",
                per_page: 100,
                page,
              });
              for (const it of res.data) existingTitleToNumber.set(it.title, it.number);
              if (res.data.length < 100) break;
            }
            core.info(`Cached ${existingTitleToNumber.size} existing issues (title -> number).`);

            // -----------------------------
            // Cache epics by title
            // -----------------------------
            const epicsByTitle = new Map();
            core.info('Fetching epics (label: "type:epic")...');
            const epics = await github.paginate(github.rest.issues.listForRepo, {
              ...context.repo,
              state: "all",
              labels: "type:epic",
              per_page: 100,
            });
            for (const e of epics) epicsByTitle.set(e.title, e);
            core.info(`Cached ${epicsByTitle.size} epics (title -> issue).`);

            // -----------------------------
            // Helpers
            // -----------------------------
            function mdChecklist(lines) {
              if (!lines || lines.length === 0) return "_(none)_";
              return lines.map(x => `- [ ] ${x}`).join("\n");
            }

            function buildBody(item, epicNumberOrNull) {
              const b = item.body || {};
              const out = [];

              if (item.type === "chore") {
                out.push(`## Chore type\n${b.chore_type || "tooling (scripts, CI, automation)"}\n`);
              }
              out.push(`## What\n${b.what || ""}\n`);
              out.push(`## Why\n${b.why || ""}\n`);
              out.push(`## Definition of Done\n${mdChecklist(b.definition_of_done || [])}\n`);
              out.push(`## System\n${b.system || ""}\n`);
              out.push(`## Priority\n${b.priority || ""}\n`);

              if (b.notes) out.push(`## Notes / links\n${b.notes}\n`);

              if (item.parent_epic) {
                if (epicNumberOrNull) out.push(`## Parent Epic\n- #${epicNumberOrNull}\n`);
                else out.push(`## Parent Epic\n- ${item.parent_epic}\n`);
              }

              out.push(`---\n**Area:** ${item.area || ""}  \n**Estimate:** ${item.estimate || ""}  \n**Risk:** ${item.risk || ""}\n`);
              return out.join("\n").trim() + "\n";
            }

            function stripTypePrefix(s) {
              return (s || "").replace(/^\s*(feat|chore|bug|tech-debt|config)\s*:\s*/i, "").trim();
            }

            function normalize(s) {
              if (!s) return "";
              return String(s)
                .replace(/\r\n/g, "\n")
                // arrows
                .replace(/[→⇒➜➔]/g, "->")
                // dashes
                .replace(/[—–]/g, "-")
                // smart quotes
                .replace(/[“”]/g, '"')
                .replace(/[‘’]/g, "'")
                // collapse whitespace
                .replace(/\s+/g, " ")
                .trim()
                .toLowerCase();
            }

            function unique(arr) {
              return Array.from(new Set(arr.filter(Boolean)));
            }

            function buildCandidates(item) {
              const t = (item.title || "").trim();
              const raw = (item.raw_title || "").trim();

              const cands = unique([
                t,
                stripTypePrefix(t),
                raw,
                stripTypePrefix(raw),
              ]);

              // also try variants with "->" vs "→" etc (normalize will handle it, but keep for logging)
              return cands;
            }

            // Link map: epicNumber -> { epicTitle, lines: [{issueNumber, candidates}] }
            const epicLinkRequests = new Map();

            function queueEpicLink(epic, issueNumber, candidates) {
              if (!updateEpic || !epic) return;
              if (!epicLinkRequests.has(epic.number)) {
                epicLinkRequests.set(epic.number, { epicTitle: epic.title, lines: [] });
              }
              epicLinkRequests.get(epic.number).lines.push({ issueNumber, candidates });
              core.info(`Queued epic checklist update: ${epic.title} <- #${issueNumber}`);
            }

            // -----------------------------
            // Create or skip issues, and queue epic linking
            // -----------------------------
            let created = 0, skipped = 0;

            for (const item of items) {
              const title = (item.title || "").trim();
              if (!title) continue;

              const epic = item.parent_epic ? epicsByTitle.get(item.parent_epic) : null;
              const candidates = buildCandidates(item);

              // If exists, skip creation but still link
              const existingNumber = existingTitleToNumber.get(title);

              if (existingNumber) {
                skipped++;
                core.info(`Skip (exists): #${existingNumber} ${title}`);
                if (epic) queueEpicLink(epic, existingNumber, candidates);
                continue;
              }

              if (dryRun) {
                core.info(`[DRY-RUN] Would create: "${title}" | milestone #${msNumber} | labels=${JSON.stringify(item.labels || [])} | parent_epic=${epic ? "#" + epic.number : (item.parent_epic || "(none)")}`);
                continue;
              }

              const createdIssue = await github.rest.issues.create({
                ...context.repo,
                title,
                body: buildBody(item, epic ? epic.number : null),
                milestone: msNumber,
                labels: item.labels || [],
              });

              created++;
              const newNum = createdIssue.data.number;
              core.info(`Created #${newNum}: ${title}`);

              // Track new title to prevent duplicates within same run
              existingTitleToNumber.set(title, newNum);

              if (epic) queueEpicLink(epic, newNum, candidates);
            }

            // -----------------------------
            // Apply epic checklist updates (batched per epic)
            // -----------------------------
            function linkIntoEpicBody(epicBody, linkReqs) {
              if (!epicBody) return { body: epicBody, updatedCount: 0, misses: [] };

              const lines = epicBody.split("\n");
              const misses = [];
              let updatedCount = 0;

              // Precompute normalized checklist line content for task lines.
              // Task item regex: "- [ ] text" or "* [x] text"
              const taskRe = /^(\s*[-*]\s+\[( |x|X)\]\s+)(.*)$/;

              // Build a lookup of indices by normalized text
              // We'll allow matches against:
              //  - raw text
              //  - raw text with leading "#123 " stripped
              const indexed = lines.map((ln, idx) => {
                const m = ln.match(taskRe);
                if (!m) return null;
                const prefix = m[1];
                const text = m[3] || "";
                const textNoLink = text.replace(/^\s*#\d+\s+/, "").trim();
                return {
                  idx,
                  prefix,
                  originalText: text,
                  textNoLink,
                  norm: normalize(text),
                  normNoLink: normalize(textNoLink),
                  checked: m[2].toLowerCase() === "x",
                };
              }).filter(Boolean);

              function findMatchIndex(candsNorm) {
                // Prefer exact match (noLink), then exact match (full), then contains
                for (const c of candsNorm) {
                  const exactNoLink = indexed.find(x => x.normNoLink === c);
                  if (exactNoLink) return exactNoLink;
                }
                for (const c of candsNorm) {
                  const exactFull = indexed.find(x => x.norm === c);
                  if (exactFull) return exactFull;
                }
                for (const c of candsNorm) {
                  const containsNoLink = indexed.find(x => x.normNoLink.includes(c) || c.includes(x.normNoLink));
                  if (containsNoLink) return containsNoLink;
                }
                return null;
              }

              for (const req of linkReqs) {
                const issueNumber = req.issueNumber;
                const candsNorm = req.candidates.map(normalize).filter(Boolean);

                const match = findMatchIndex(candsNorm);
                if (!match) {
                  misses.push({ issueNumber, candidates: req.candidates });
                  continue;
                }

                // If already starts with "#<issueNumber> " then nothing to do
                const already = match.textNoLink.startsWith(`#${issueNumber} `) || match.originalText.trim().startsWith(`#${issueNumber} `);
                if (already) continue;

                // Rewrite line, preserving checkbox and original human text (without any existing #123 prefix)
                const rewrittenText = `#${issueNumber} ${match.textNoLink}`;
                lines[match.idx] = `${match.prefix}${rewrittenText}`;
                updatedCount++;
              }

              return { body: lines.join("\n"), updatedCount, misses };
            }

            const epicIds = Array.from(epicLinkRequests.keys());

            if (updateEpic && epicIds.length > 0) {
              core.info(`Applying ${epicIds.length} epic body update(s)...`);

              for (const epicNumber of epicIds) {
                const req = epicLinkRequests.get(epicNumber);

                // Fetch fresh epic body each time (avoid stale writes)
                const epicGet = await github.rest.issues.get({
                  ...context.repo,
                  issue_number: epicNumber,
                });

                const before = epicGet.data.body || "";
                const { body: after, updatedCount, misses } = linkIntoEpicBody(before, req.lines);

                if (misses.length > 0) {
                  for (const miss of misses) {
                    core.info(
                      `Epic checklist line not found in "${req.epicTitle}" for any of: ${JSON.stringify(miss.candidates)}`
                    );
                  }
                }

                if (updatedCount === 0) {
                  core.info(`No epic checklist changes needed for epic #${epicNumber} (${req.epicTitle}).`);
                  continue;
                }

                if (dryRun) {
                  core.info(`[DRY-RUN] Would update epic #${epicNumber} (${req.epicTitle}) with ${updatedCount} checklist link(s).`);
                  continue;
                }

                await github.rest.issues.update({
                  ...context.repo,
                  issue_number: epicNumber,
                  body: after,
                });

                core.info(`Updated epic #${epicNumber} checklist (batched, ${updatedCount} link(s)).`);
              }
            }

            if (dryRun) core.info(`DRY-RUN complete.`);
            else core.info(`Done. Created: ${created}, Skipped: ${skipped}`);
